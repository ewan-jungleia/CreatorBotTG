=== META ===
cwd: /Users/ewanlanglais/CreatorBotTG
git_remote: https://github.com/ewan-jungleia/CreatorBotTG
git_branch: main
git_head: 501fb1c94460b0e2033565e99ad71a6d34645b2a
node: v24.7.0
npm: 11.5.1
=== TREE ===
.
./.vercel
./.vercel/project.json
./.vercel/README.txt
./CreatorBotTG-dump-20251024-151438.txt
./.gitignore
./package.json
./api
./api/_kv.js
./api/_ai.js
./api/creator.js
./api/diag.js
./.git
=== FILES (avec num√©ros de ligne) ===
----- FILE 1: ./.gitignore -----
     1	.vercel

----- FILE 2: ./.vercel/README.txt -----
     1	> Why do I have a folder named ".vercel" in my project?
     2	The ".vercel" folder is created when you link a directory to a Vercel project.
     3	
     4	> What does the "project.json" file contain?
     5	The "project.json" file contains:
     6	- The ID of the Vercel project that you linked ("projectId")
     7	- The ID of the user or team your Vercel project is owned by ("orgId")
     8	
     9	> Should I commit the ".vercel" folder?
    10	No, you should not share the ".vercel" folder with anyone.
    11	Upon creation, it will be automatically added to your ".gitignore" file.

----- FILE 3: ./.vercel/project.json -----
     1	{"projectId":"prj_6TSXPLCOS7feiWYPG96vI2dzMh0g","orgId":"team_Fbiq9Lbr0M8425oMFKaeFSne","projectName":"creator-bot-tg"}
----- FILE 4: ./CreatorBotTG-dump-20251024-151438.txt -----
     1	=== META ===
     2	cwd: /Users/ewanlanglais/CreatorBotTG
     3	git_remote: https://github.com/ewan-jungleia/CreatorBotTG
     4	git_branch: main
     5	git_head: 501fb1c94460b0e2033565e99ad71a6d34645b2a
     6	node: v24.7.0
     7	npm: 11.5.1
     8	=== TREE ===
     9	.
    10	./.vercel
    11	./.vercel/project.json
    12	./.vercel/README.txt
    13	./CreatorBotTG-dump-20251024-151438.txt
    14	./.gitignore
    15	./package.json
    16	./api
    17	./api/_kv.js
    18	./api/_ai.js
    19	./api/creator.js
    20	./api/diag.js
    21	./.git
    22	=== FILES (avec num√©ros de ligne) ===
    23	----- FILE 1: ./.gitignore -----
    24	     1	.vercel
    25	
    26	----- FILE 2: ./.vercel/README.txt -----
    27	     1	> Why do I have a folder named ".vercel" in my project?
    28	     2	The ".vercel" folder is created when you link a directory to a Vercel project.
    29	     3	
    30	     4	> What does the "project.json" file contain?
    31	     5	The "project.json" file contains:
    32	     6	- The ID of the Vercel project that you linked ("projectId")
    33	     7	- The ID of the user or team your Vercel project is owned by ("orgId")
    34	     8	
    35	     9	> Should I commit the ".vercel" folder?
    36	    10	No, you should not share the ".vercel" folder with anyone.
    37	    11	Upon creation, it will be automatically added to your ".gitignore" file.
    38	
    39	----- FILE 3: ./.vercel/project.json -----
    40	     1	{"projectId":"prj_6TSXPLCOS7feiWYPG96vI2dzMh0g","orgId":"team_Fbiq9Lbr0M8425oMFKaeFSne","projectName":"creator-bot-tg"}
    41	----- FILE 4: ./CreatorBotTG-dump-20251024-151438.txt -----

----- FILE 5: ./api/_ai.js -----
     1	export async function summarizePrompt(userText) {
     2	  const apiKey = process.env.OPENAI_API_KEY;
     3	  if (!apiKey) throw new Error('OPENAI_API_KEY missing');
     4	
     5	  const body = {
     6	    model: "gpt-4o-mini",
     7	    messages: [
     8	      { role: "system", content: "Tu es un assistant qui r√©sume efficacement une demande de cr√©ation de bot. Reformule en fran√ßais avec tes mots, sans copier-coller le texte d‚Äôorigine. Donne un r√©sum√© structur√©: Objectif, Contraintes, Livrables, Crit√®res de r√©ussite. 6 √† 10 lignes max." },
     9	      { role: "user", content: userText }
    10	    ],
    11	    temperature: 0.2
    12	  };
    13	
    14	  const r = await fetch("https://api.openai.com/v1/chat/completions", {
    15	    method: "POST",
    16	    headers: {
    17	      "Authorization": `Bearer ${apiKey}`,
    18	      "Content-Type": "application/json"
    19	    },
    20	    body: JSON.stringify(body)
    21	  });
    22	
    23	  if (!r.ok) {
    24	    const t = await r.text().catch(()=> "");
    25	    throw new Error("OpenAI error: " + r.status + " " + t);
    26	  }
    27	
    28	  const j = await r.json();
    29	  const content = j.choices?.[0]?.message?.content?.trim() || "";
    30	  return content;
    31	}

----- FILE 6: ./api/_kv.js -----
     1	const { KV_REST_API_URL, KV_REST_API_TOKEN } = process.env;
     2	
     3	async function kvFetch(path, method = 'GET', body) {
     4	  const url = `${KV_REST_API_URL}${path}`;
     5	  const res = await fetch(url, {
     6	    method,
     7	    headers: {
     8	      Authorization: `Bearer ${KV_REST_API_TOKEN}`,
     9	      'Content-Type': 'application/json'
    10	    },
    11	    body: body ? JSON.stringify(body) : undefined
    12	  });
    13	  if (!res.ok) throw new Error(`KV ${method} ${path} -> ${res.status}`);
    14	  return res.json();
    15	}
    16	
    17	// D√©paquetage profond (g√®re {result:{value:"‚Ä¶"}}, strings JSON imbriqu√©es, etc.)
    18	function deepUnwrap(v) {
    19	  let cur = v;
    20	  let depth = 0;
    21	  while (depth < 6) {
    22	    // Upstash peut renvoyer { result: X }
    23	    if (cur && typeof cur === 'object' && 'result' in cur) {
    24	      cur = cur.result;
    25	      depth++; continue;
    26	    }
    27	    // Upstash peut renvoyer { value: X }
    28	    if (cur && typeof cur === 'object' && 'value' in cur && Object.keys(cur).length === 2 && 'ex' in cur) {
    29	      // cas diag: { value:"json", ex:900 }
    30	      cur = cur.value;
    31	      depth++; continue;
    32	    }
    33	    if (cur && typeof cur === 'object' && 'value' in cur && Object.keys(cur).length === 1) {
    34	      cur = cur.value;
    35	      depth++; continue;
    36	    }
    37	    // Si c'est une string JSON, on parse
    38	    if (typeof cur === 'string') {
    39	      const s = cur.trim();
    40	      if ((s.startsWith('{') && s.endsWith('}')) || (s.startsWith('[') && s.endsWith(']'))) {
    41	        try { cur = JSON.parse(s); depth++; continue; } catch { /* stop */ }
    42	      }
    43	    }
    44	    break;
    45	  }
    46	  return cur;
    47	}
    48	
    49	export async function getJSON(key, fallback = null) {
    50	  try {
    51	    const r = await kvFetch(`/get/${encodeURIComponent(key)}`);
    52	    if (r == null) return fallback;
    53	    const un = deepUnwrap(r);
    54	    return (un == null) ? fallback : un;
    55	  } catch {
    56	    return fallback;
    57	  }
    58	}
    59	
    60	export async function setJSON(key, val, ttlSec) {
    61	  // Toujours stocker un JSON propre (pas de sur-emballage)
    62	  const body = { value: JSON.stringify(val) };
    63	  if (ttlSec) body.ttl = ttlSec;
    64	  await kvFetch(`/set/${encodeURIComponent(key)}`, 'POST', body);
    65	  return true;
    66	}
    67	
    68	export async function del(key) {
    69	  await kvFetch(`/del/${encodeURIComponent(key)}`, 'POST');
    70	  return true;
    71	}
    72	
    73	const NS = 'creatorbottg';
    74	function k(...parts) { return [NS, ...parts].join(':'); }
    75	
    76	export function keysForUser(uid) {
    77	  return {
    78	    budgetGlobal: k('budget','global'),
    79	    projectsList: k('projects','list'),
    80	    project: (pid) => k('project', pid),
    81	    secretsGlobal: k('secrets','global'),
    82	    secretsProject: (pid) => k('secrets','project', pid),
    83	    tmp: k('tmp', uid),      // m√©moire par utilisateur
    84	    usageGlobal: k('usage','global'),
    85	    usageProject: (pid) => k('usage','project', pid)
    86	  };
    87	}
    88	
    89	export function now(){ return Math.floor(Date.now()/1000); }
    90	
    91	export function pricePer1k(){
    92	  const envP = process.env.PRICE_PER_1K;
    93	  if (envP) return Number(envP);
    94	  return 0.005;
    95	}
    96	
    97	export function estimateTokens(str){
    98	  if (!str) return 0;
    99	  const chars = [...String(str)].length;
   100	  return Math.max(1, Math.round(chars/4));
   101	}
   102	
   103	export async function addUsage({ projectId, tokens }) {
   104	  const userUsageKey = `${NS}:usage:global`;
   105	  const projUsageKey = `${NS}:usage:project:${projectId || 'none'}`;
   106	  const p = pricePer1k();
   107	  const euros = (tokens/1000)*p;
   108	
   109	  const u = (await getJSON(userUsageKey)) || { tokens:0, euros:0, history:[] };
   110	  u.tokens += tokens;
   111	  u.euros = Number((u.euros + euros).toFixed(4));
   112	  u.history.push({ ts: now(), projectId: projectId || null, tokens, euros: Number(euros.toFixed(4)) });
   113	  await setJSON(userUsageKey, u);
   114	
   115	  const up = (await getJSON(projUsageKey)) || { tokens:0, euros:0, history:[] };
   116	  up.tokens += tokens;
   117	  up.euros = Number((up.euros + euros).toFixed(4));
   118	  up.history.push({ ts: now(), tokens, euros: Number(euros.toFixed(4)) });
   119	  await setJSON(projUsageKey, up);
   120	
   121	  return { euros: Number(euros.toFixed(4)) };
   122	}

----- FILE 7: ./api/creator.js -----
     1	const API = `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}`;
     2	const ADMIN = String(process.env.ADMIN_TELEGRAM_ID || "").trim();
     3	import { getJSON, setJSON } from './_kv.js';
     4	import { summarizePrompt } from './_ai.js';
     5	
     6	function kb(rows){ return { reply_markup:{ inline_keyboard: rows } }; }
     7	function esc(s){ return String(s||'').replace(/[<&>]/g,c=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[c])); }
     8	
     9	async function reply(chatId, text, extra){
    10	  await fetch(`${API}/sendMessage`, {
    11	    method:'POST', headers:{'Content-Type':'application/json'},
    12	    body: JSON.stringify({ chat_id: chatId, text, parse_mode:'HTML', ...extra })
    13	  });
    14	}
    15	
    16	function keysFor(uid){
    17	  const base = 'creatorbottg';
    18	  return {
    19	    tmp: `${base}:tmp:${uid}`,
    20	    projects: `${base}:projects:${uid}`
    21	  };
    22	}
    23	
    24	async function getTMP(uid){
    25	  const k = keysFor(uid).tmp;
    26	  const j = await getJSON(k);
    27	  try{
    28	    if (!j) return null;
    29	    const v = typeof j.value === 'string' ? JSON.parse(j.value) : j.value;
    30	    return v || null;
    31	  }catch{ return null; }
    32	}
    33	
    34	async function setTMP(uid, obj){
    35	  const k = keysFor(uid).tmp;
    36	  await setJSON(k, obj, 1800);
    37	}
    38	
    39	function isAdmin(uid){ return ADMIN ? String(uid)===ADMIN : true; }
    40	
    41	async function showMenu(chatId){
    42	  await reply(chatId, 'CreatorBot-TG en ligne ‚úÖ\nChoisis une action :', kb([
    43	    [{ text:'üÜï Nouveau projet', callback_data:'act:new' }, { text:'üìÅ Projets', callback_data:'act:list' }],
    44	    [{ text:'üí∞ Budget', callback_data:'act:budget' }, { text:'üîë Secrets', callback_data:'act:secrets' }],
    45	    [{ text:'üì¶ ZIP', callback_data:'act:zip' }, { text:'‚ôªÔ∏è Reset', callback_data:'act:reset' }]
    46	  ]));
    47	}
    48	
    49	async function askTitle(chatId, uid){
    50	  await setTMP(uid, { step:'title' });
    51	  await reply(chatId, 'Titre du projet ?', kb([[{ text:'‚¨Ö Retour menu', callback_data:'act:menu' }]]));
    52	}
    53	
    54	async function askBudget(chatId, uid){
    55	  const tmp = await getTMP(uid) || {};
    56	  const title = tmp.title || '';
    57	  await setTMP(uid, { step:'budget', title });
    58	  await reply(chatId, `Budget pour <b>${esc(title)}</b>`, kb([
    59	    [{ text:'Cap 10‚Ç¨', callback_data:'b:cap:1000' }, { text:'Cap 20‚Ç¨', callback_data:'b:cap:2000' }],
    60	    [{ text:'Alerte 1‚Ç¨', callback_data:'b:alert:100' }, { text:'Alerte 2‚Ç¨', callback_data:'b:alert:200' }],
    61	    [{ text:'OK', callback_data:'b:ok' }, { text:'‚¨Ö Annuler', callback_data:'act:menu' }]
    62	  ]));
    63	}
    64	
    65	async function askPrompt(chatId, uid){
    66	  const tmp = await getTMP(uid) || {};
    67	  await setTMP(uid, { step:'prompt', title: tmp.title, capCents: tmp.capCents||0, alertStepCents: tmp.alertStepCents||0 });
    68	  await reply(chatId, 'Envoie le prompt principal (objectif, contraintes, livrables, etc.)', kb([[{ text:'‚¨Ö Annuler', callback_data:'act:menu' }]]));
    69	}
    70	
    71	async function showConfirm(chatId, uid){
    72	  const tmp = await getTMP(uid) || {};
    73	  const summary = tmp.summary || '';
    74	  await setTMP(uid, { ...tmp, step:'confirm' });
    75	  await reply(chatId, `R√©sum√© compris :\n\n${esc(summary)}\n\nValider ?`, kb([
    76	    [{ text:'‚úÖ Valider', callback_data:'confirm:ok' }, { text:'‚úèÔ∏è Modifier', callback_data:'confirm:edit' }],
    77	    [{ text:'‚¨Ö Annuler', callback_data:'act:menu' }]
    78	  ]));
    79	}
    80	
    81	
    82	async function handleText(chatId, uid, text){
    83	  // PATCH anti-bug: fallback par d√©faut sur 'title', puis encha√Æne vers Budget
    84	  try {
    85	    const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
    86	    const keys = keysForUser(String(userId));
    87	    let tmp = (await getJSON(keys.tmp)) || {};
    88	    if (!tmp.step) { tmp.step = 'title'; await setJSON(keys.tmp, tmp, 1800); }
    89	
    90	    if (tmp.step === 'title') {
    91	      const title = String(text || '').trim();
    92	      if (!title) { await reply(chatId, 'Envoie un titre valide.'); return; }
    93	      tmp.title = title;
    94	      tmp.step = 'budget';
    95	      await setJSON(keys.tmp, tmp, 1800);
    96	
    97	      const kb = kbInline([
    98	        [{ text:'Cap 10‚Ç¨',  callback_data:'bud:cap:1000' }, { text:'Cap 20‚Ç¨',  callback_data:'bud:cap:2000' }],
    99	        [{ text:'Alerte 1‚Ç¨',callback_data:'bud:alert:100' }, { text:'Alerte 2‚Ç¨',callback_data:'bud:alert:200' }],
   100	        [{ text:'OK',      callback_data:'bud:ok'        }, { text:'‚¨ÖÔ∏è Annuler', callback_data:'act:menu' }]
   101	      ]);
   102	      await reply(chatId, `Budget pour <b>${esc(title)}</b>`, kb);
   103	      return;
   104	    }
   105	  } catch(e) {
   106	    try { await reply(chatId, 'Erreur: ' + String(e)); } catch {}
   107	  }
   108	{
   109	    const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
   110	    const keys = keysForUser(String(userId));
   111	    const tmp = (await getJSON(keys.tmp)) || {};
   112	    if (tmp.step === 'secrets') {
   113	      const lines = String(text||'').split(/\r?\n/).map(v=>v.trim()).filter(Boolean);
   114	      const envs = {};
   115	      for (const l of lines){
   116	        const m = l.match(/^([A-Z0-9_]+)s*=s*(.+)$/);
   117	        if (m) envs[m[1]] = m[2];
   118	      }
   119	      tmp.secrets = Object.assign({}, tmp.secrets||{}, envs);
   120	      await setJSON(keys.tmp, tmp, 1800);
   121	
   122	      const need = ['TELEGRAM_BOT_TOKEN','OPENAI_API_KEY','KV_REST_API_URL','KV_REST_API_TOKEN'];
   123	      const missing = need.filter(k=>!tmp.secrets?.[k]);
   124	
   125	      if (missing.length){
   126	        await reply(chatId, "Re√ßu. Il manque encore : " + missing.join(', ') + ". Ajoute-les (m√™me format KEY=VALUE).");
   127	      }else{
   128	        const kb = kbInline([
   129	          [{ text:'üöÄ G√©n√©rer le projet', callback_data:'gen:go' }],
   130	          [{ text:'‚¨ÖÔ∏è Annuler', callback_data:'act:menu' }]
   131	        ]);
   132	        await reply(chatId, "Parfait, j‚Äôai tout. Pr√™t √† **g√©n√©rer le projet** (code + README).", kb);
   133	      }
   134	      return;
   135	    }
   136	  }
   137	const tmp = await getTMP(uid);
   138	  if (!tmp) return showMenu(chatId);
   139	
   140	  if (tmp.step === 'title'){
   141	    const title = text.trim();
   142	    await setTMP(uid, { step:'budget', title });
   143	    await reply(chatId, `Titre enregistr√© : <b>${esc(title)}</b>`);
   144	    await askBudget(chatId, uid);
   145	    return;
   146	  }
   147	
   148	  if (tmp.step === 'prompt'){
   149	    const userPrompt = text.trim();
   150	    await reply(chatId, 'Je r√©fl√©chis au r√©sum√©‚Ä¶');
   151	    let summary = '';
   152	    try{ summary = await summarizePrompt(userPrompt); }
   153	    catch(e){ summary = `Impossible de r√©sumer: ${String(e)}`; }
   154	    await setTMP(uid, { step:'confirm', title: tmp.title, capCents: tmp.capCents||0, alertStepCents: tmp.alertStepCents||0, prompt:userPrompt, summary });
   155	    await showConfirm(chatId, uid);
   156	    return;
   157	  }
   158	
   159	  await showMenu(chatId);
   160	}
   161	
   162	async function handleCallback(chatId, uid, data){
   163	  
   164	  
   165	  
   166	  
   167	  if (data && data.startsWith('gen:go')) {
   168	    const { keysForUser, getJSON } = await import('./_kv.js');
   169	    const keys = keysForUser(String(userId));
   170	    const tmp = (await getJSON(keys.tmp)) || {};
   171	    await reply(chatId, "OK, je g√©n√®re les fichiers du projet (code + README)‚Ä¶");
   172	    // Ici, tu brancheras la vraie g√©n√©ration ZIP/Git. Pour l‚Äôinstant on confirme.
   173	    await reply(chatId, "‚úÖ Projet g√©n√©r√© (brouillon). √âtape suivante: packaging ZIP et d√©ploiement automatique.");
   174	    return;
   175	  }
   176	if (data && data.startsWith('sec:help')) {
   177	    await reply(chatId, "‚Ä¢ TELEGRAM_BOT_TOKEN : @BotFather ‚Üí /newbot ‚Üí Copier le token.\n‚Ä¢ OPENAI_API_KEY : https://platform.openai.com/\n‚Ä¢ KV (Upstash) : cr√©er une base REST et r√©cup√©rer URL & TOKEN.");
   178	    return;
   179	  }
   180	if (data && data.startsWith('plan:ok')) {
   181	    const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
   182	    const keys = keysForUser(String(userId));
   183	    const tmp = (await getJSON(keys.tmp)) || {};
   184	    tmp.step = 'secrets';
   185	    await setJSON(keys.tmp, tmp, 1800);
   186	    const kb = kbInline([
   187	      [{ text:'‚ùì O√π trouver les tokens ?', callback_data:'sec:help' }],
   188	      [{ text:'‚¨ÖÔ∏è Annuler', callback_data:'act:menu' }]
   189	    ]);
   190	    await reply(chatId,
   191	      "Parfait. Maintenant, envoie-moi les **secrets** n√©cessaires dans ce format :\n\n" +
   192	      "TELEGRAM_BOT_TOKEN=xxxx\nOPENAI_API_KEY=xxxx\nKV_REST_API_URL=xxxx\nKV_REST_API_TOKEN=xxxx\n\n" +
   193	      "Tu peux ne fournir que ceux dont tu disposes, je te dirai s‚Äôil en manque.",
   194	      kb
   195	    );
   196	    return;
   197	  }
   198	// Suite apr√®s validation du r√©sum√©
   199	  if (data && data.startsWith('sum:ok')) {
   200	    await onSummaryOk(chatId, userId);
   201	    return;
   202	  }
   203	  if (data && data.startsWith('sum:edit')) {
   204	    const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
   205	    const keys = keysForUser(String(userId));
   206	    const tmp = (await getJSON(keys.tmp)) || {};
   207	    tmp.step = 'prompt';
   208	    await setJSON(keys.tmp, tmp, 1800);
   209	    await reply(chatId, 'Ok, renvoie le prompt principal (objectif, contraintes, livrables, etc.).');
   210	    return;
   211	  }
   212	const tmp = await getTMP(uid) || {};
   213	
   214	  if (data === 'act:menu'){ await setTMP(uid, null); await showMenu(chatId); return; }
   215	  if (data === 'act:new'){ await askTitle(chatId, uid); return; }
   216	
   217	  if (data.startsWith('b:')){
   218	    const [_, kind, val] = data.split(':');
   219	    if (tmp.step!=='budget'){ await askBudget(chatId, uid); return; }
   220	    if (kind==='cap'){ await setTMP(uid, { ...tmp, capCents:Number(val) }); await reply(chatId, `Cap d√©fini: ${(Number(val)/100).toFixed(2)} ‚Ç¨`); }
   221	    if (kind==='alert'){ await setTMP(uid, { ...tmp, alertStepCents:Number(val) }); await reply(chatId, `Alerte: ${(Number(val)/100).toFixed(2)} ‚Ç¨`); }
   222	    if (kind==='ok'){ await askPrompt(chatId, uid); }
   223	    return;
   224	  }
   225	
   226	  if (data === 'confirm:edit'){
   227	    await askPrompt(chatId, uid);
   228	    return;
   229	  }
   230	
   231	  if (data === 'confirm:ok'){
   232	    await setTMP(uid, { ...tmp, step:'done' });
   233	    await reply(chatId, '‚úÖ Valid√©. √âtapes suivantes : faisabilit√©, plan strat√©gique, plan d‚Äôaction, besoins et livrables. (On les g√©n√®re juste apr√®s.)');
   234	    return;
   235	  }
   236	
   237	  if (data === 'act:list'){ await reply(chatId,'Projets (√† venir).'); return; }
   238	  if (data === 'act:budget'){ await reply(chatId,'Budget global (√† venir).'); return; }
   239	  if (data === 'act:secrets'){ await reply(chatId,'Secrets (√† venir).'); return; }
   240	  if (data === 'act:zip'){ await reply(chatId,'ZIP (√† venir).'); return; }
   241	  if (data === 'act:reset'){ await setTMP(uid, null); await reply(chatId,'√âtat r√©initialis√©.'); await showMenu(chatId); return; }
   242	
   243	  await showMenu(chatId);
   244	}
   245	
   246	export default async function handler(req,res){
   247	  if (req.method === 'GET') return res.status(200).send('OK');
   248	  if (req.method !== 'POST') return res.status(405).json({ ok:false });
   249	
   250	  try{
   251	    const u = req.body || {};
   252	    const msg = u.message;
   253	    const cb  = u.callback_query;
   254	
   255	    if (msg && msg.text){
   256	      const chatId = msg.chat?.id;
   257	      const fromId = msg.from?.id;
   258	      if (!isAdmin(fromId)){ await reply(chatId,'‚ùå Acc√®s refus√© ‚Äì bot priv√©.'); return res.json({ok:true}); }
   259	      if (msg.text === '/start'){ await showMenu(chatId); return res.json({ok:true}); }
   260	      await handleText(chatId, fromId, msg.text);
   261	      return res.json({ ok:true });
   262	    }
   263	
   264	    if (cb){
   265	      const chatId = cb.message?.chat?.id;
   266	      const fromId = cb.from?.id;
   267	      if (!isAdmin(fromId)){ await reply(chatId,'‚ùå Acc√®s refus√© ‚Äì bot priv√©.'); return res.json({ok:true}); }
   268	      await handleCallback(chatId, fromId, cb.data||'');
   269	      await fetch(`${API}/answerCallbackQuery`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ callback_query_id: cb.id }) });
   270	      return res.json({ ok:true });
   271	    }
   272	
   273	    return res.json({ ok:true });
   274	  }catch(e){
   275	    return res.status(200).json({ ok:false, error: String(e) });
   276	  }
   277	}
   278	
   279	
   280	async function askOpenAI(messages){
   281	  const api = process.env.OPENAI_API_KEY;
   282	  const model = process.env.OPENAI_MODEL || 'gpt-4o-mini';
   283	  const r = await fetch('https://api.openai.com/v1/chat/completions',{
   284	    method:'POST',
   285	    headers:{ 'Content-Type':'application/json', 'Authorization':'Bearer '+api },
   286	    body: JSON.stringify({ model, messages, temperature:0.3 })
   287	  });
   288	  const j = await r.json();
   289	  const txt = j?.choices?.[0]?.message?.content?.trim() || '';
   290	  return txt;
   291	}
   292	
   293	async function onSummaryOk(chatId, userId){
   294	  const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
   295	  const keys = keysForUser(String(userId));
   296	  const tmp  = (await getJSON(keys.tmp)) || {};
   297	  const title = tmp.title || 'Projet';
   298	  const prompt = tmp.prompt || '';
   299	
   300	  const sys = `Tu es un architecte logiciel Telegram ultra rigoureux.
   301	R√©ponds en fran√ßais, format clair avec titres **gras** et listes.
   302	Tu dois fournir: Faisabilit√©, Plan strat√©gique (phases), Plan d'action (t√¢ches), Besoins (inputs & secrets), Livrables (code, README, d√©ploiement).
   303	Sois concret, pas verbeux.`;
   304	
   305	  const usr = `Titre: ${title}
   306	Brief utilisateur:
   307	${prompt}`;
   308	
   309	  // Message d'attente
   310	  await reply(chatId, 'Je pr√©pare la faisabilit√© et le plan‚Ä¶');
   311	
   312	  const plan = await askOpenAI([
   313	    { role:'system', content: sys },
   314	    { role:'user', content: usr }
   315	  ]);
   316	
   317	  // M√©morise et propose la suite
   318	  tmp.step = 'plan';
   319	  tmp.plan = plan;
   320	  await setJSON(keys.tmp, tmp, 1800);
   321	
   322	  const kb = kbInline([
   323	    [{ text:'‚úÖ Continuer', callback_data:'plan:ok' }],
   324	    [{ text:'‚úèÔ∏è Modifier le brief', callback_data:'sum:edit' }],
   325	    [{ text:'‚¨ÖÔ∏è Annuler', callback_data:'act:menu' }]
   326	  ]);
   327	
   328	  await reply(chatId, `**Faisabilit√© & Plan pour ${esc(title)}**\n\n${plan}`, kb);
   329	}

----- FILE 8: ./api/diag.js -----
     1	import { getJSON, setJSON, keysForUser } from './_kv.js';
     2	export default async function handler(req, res) {
     3	  try {
     4	    if (req.query?.dump === '1') {
     5	      const uid = String(req.query.uid || '').trim();
     6	      const keys = keysForUser(uid || 'debug');
     7	      const state = {
     8	        uid,
     9	        tmp: uid ? await getJSON(keys.tmp) : null,
    10	        budgetGlobal: await getJSON(keys.budgetGlobal),
    11	        projectsList: await getJSON(keys.projectsList),
    12	      };
    13	      return res.status(200).json({ ok: true, state });
    14	    }
    15	    if (req.query?.kvtest === '1') {
    16	      const key = String(req.query.key || 'creatorbottg:test');
    17	      const val = String(req.query.val || 'hello');
    18	      await setJSON(key, { v: val, ts: Date.now() });
    19	      const back = await getJSON(key);
    20	      return res.status(200).json({ ok: true, set: { key, val }, get: back });
    21	    }
    22	    return res.status(200).json({ ok:true, ts: Date.now() });
    23	  } catch (e) {
    24	    return res.status(200).json({ ok:false, error: String(e) });
    25	  }
    26	}

----- FILE 9: ./package.json -----
     1	{
     2	  "name": "creator-bot-tg",
     3	  "version": "1.0.0",
     4	  "private": true,
     5	  "type": "module",
     6	  "dependencies": {
     7	    "adm-zip": "0.5.10"
     8	  },
     9	  "engines": {
    10	    "node": "20.x"
    11	  }
    12	}

