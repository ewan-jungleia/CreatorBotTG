=== META ===
cwd: /Users/ewanlanglais/CreatorBotTG
git_remote: https://github.com/ewan-jungleia/CreatorBotTG
git_branch: main
git_head: 501fb1c94460b0e2033565e99ad71a6d34645b2a
node: v24.7.0
npm: 11.5.1
=== TREE ===
.
./.vercel
./.vercel/project.json
./.vercel/README.txt
./CreatorBotTG-dump-20251024-151438.txt
./.gitignore
./package.json
./api
./api/_kv.js
./api/_ai.js
./api/creator.js
./api/diag.js
./.git
=== FILES (avec numéros de ligne) ===
----- FILE 1: ./.gitignore -----
     1	.vercel

----- FILE 2: ./.vercel/README.txt -----
     1	> Why do I have a folder named ".vercel" in my project?
     2	The ".vercel" folder is created when you link a directory to a Vercel project.
     3	
     4	> What does the "project.json" file contain?
     5	The "project.json" file contains:
     6	- The ID of the Vercel project that you linked ("projectId")
     7	- The ID of the user or team your Vercel project is owned by ("orgId")
     8	
     9	> Should I commit the ".vercel" folder?
    10	No, you should not share the ".vercel" folder with anyone.
    11	Upon creation, it will be automatically added to your ".gitignore" file.

----- FILE 3: ./.vercel/project.json -----
     1	{"projectId":"prj_6TSXPLCOS7feiWYPG96vI2dzMh0g","orgId":"team_Fbiq9Lbr0M8425oMFKaeFSne","projectName":"creator-bot-tg"}
----- FILE 4: ./CreatorBotTG-dump-20251024-151438.txt -----
     1	=== META ===
     2	cwd: /Users/ewanlanglais/CreatorBotTG
     3	git_remote: https://github.com/ewan-jungleia/CreatorBotTG
     4	git_branch: main
     5	git_head: 501fb1c94460b0e2033565e99ad71a6d34645b2a
     6	node: v24.7.0
     7	npm: 11.5.1
     8	=== TREE ===
     9	.
    10	./.vercel
    11	./.vercel/project.json
    12	./.vercel/README.txt
    13	./CreatorBotTG-dump-20251024-151438.txt
    14	./.gitignore
    15	./package.json
    16	./api
    17	./api/_kv.js
    18	./api/_ai.js
    19	./api/creator.js
    20	./api/diag.js
    21	./.git
    22	=== FILES (avec numéros de ligne) ===
    23	----- FILE 1: ./.gitignore -----
    24	     1	.vercel
    25	
    26	----- FILE 2: ./.vercel/README.txt -----
    27	     1	> Why do I have a folder named ".vercel" in my project?
    28	     2	The ".vercel" folder is created when you link a directory to a Vercel project.
    29	     3	
    30	     4	> What does the "project.json" file contain?
    31	     5	The "project.json" file contains:
    32	     6	- The ID of the Vercel project that you linked ("projectId")
    33	     7	- The ID of the user or team your Vercel project is owned by ("orgId")
    34	     8	
    35	     9	> Should I commit the ".vercel" folder?
    36	    10	No, you should not share the ".vercel" folder with anyone.
    37	    11	Upon creation, it will be automatically added to your ".gitignore" file.
    38	
    39	----- FILE 3: ./.vercel/project.json -----
    40	     1	{"projectId":"prj_6TSXPLCOS7feiWYPG96vI2dzMh0g","orgId":"team_Fbiq9Lbr0M8425oMFKaeFSne","projectName":"creator-bot-tg"}
    41	----- FILE 4: ./CreatorBotTG-dump-20251024-151438.txt -----

----- FILE 5: ./api/_ai.js -----
     1	export async function summarizePrompt(userText) {
     2	  const apiKey = process.env.OPENAI_API_KEY;
     3	  if (!apiKey) throw new Error('OPENAI_API_KEY missing');
     4	
     5	  const body = {
     6	    model: "gpt-4o-mini",
     7	    messages: [
     8	      { role: "system", content: "Tu es un assistant qui résume efficacement une demande de création de bot. Reformule en français avec tes mots, sans copier-coller le texte d’origine. Donne un résumé structuré: Objectif, Contraintes, Livrables, Critères de réussite. 6 à 10 lignes max." },
     9	      { role: "user", content: userText }
    10	    ],
    11	    temperature: 0.2
    12	  };
    13	
    14	  const r = await fetch("https://api.openai.com/v1/chat/completions", {
    15	    method: "POST",
    16	    headers: {
    17	      "Authorization": `Bearer ${apiKey}`,
    18	      "Content-Type": "application/json"
    19	    },
    20	    body: JSON.stringify(body)
    21	  });
    22	
    23	  if (!r.ok) {
    24	    const t = await r.text().catch(()=> "");
    25	    throw new Error("OpenAI error: " + r.status + " " + t);
    26	  }
    27	
    28	  const j = await r.json();
    29	  const content = j.choices?.[0]?.message?.content?.trim() || "";
    30	  return content;
    31	}

----- FILE 6: ./api/_kv.js -----
     1	const { KV_REST_API_URL, KV_REST_API_TOKEN } = process.env;
     2	
     3	async function kvFetch(path, method = 'GET', body) {
     4	  const url = `${KV_REST_API_URL}${path}`;
     5	  const res = await fetch(url, {
     6	    method,
     7	    headers: {
     8	      Authorization: `Bearer ${KV_REST_API_TOKEN}`,
     9	      'Content-Type': 'application/json'
    10	    },
    11	    body: body ? JSON.stringify(body) : undefined
    12	  });
    13	  if (!res.ok) throw new Error(`KV ${method} ${path} -> ${res.status}`);
    14	  return res.json();
    15	}
    16	
    17	// Dépaquetage profond (gère {result:{value:"…"}}, strings JSON imbriquées, etc.)
    18	function deepUnwrap(v) {
    19	  let cur = v;
    20	  let depth = 0;
    21	  while (depth < 6) {
    22	    // Upstash peut renvoyer { result: X }
    23	    if (cur && typeof cur === 'object' && 'result' in cur) {
    24	      cur = cur.result;
    25	      depth++; continue;
    26	    }
    27	    // Upstash peut renvoyer { value: X }
    28	    if (cur && typeof cur === 'object' && 'value' in cur && Object.keys(cur).length === 2 && 'ex' in cur) {
    29	      // cas diag: { value:"json", ex:900 }
    30	      cur = cur.value;
    31	      depth++; continue;
    32	    }
    33	    if (cur && typeof cur === 'object' && 'value' in cur && Object.keys(cur).length === 1) {
    34	      cur = cur.value;
    35	      depth++; continue;
    36	    }
    37	    // Si c'est une string JSON, on parse
    38	    if (typeof cur === 'string') {
    39	      const s = cur.trim();
    40	      if ((s.startsWith('{') && s.endsWith('}')) || (s.startsWith('[') && s.endsWith(']'))) {
    41	        try { cur = JSON.parse(s); depth++; continue; } catch { /* stop */ }
    42	      }
    43	    }
    44	    break;
    45	  }
    46	  return cur;
    47	}
    48	
    49	export async function getJSON(key, fallback = null) {
    50	  try {
    51	    const r = await kvFetch(`/get/${encodeURIComponent(key)}`);
    52	    if (r == null) return fallback;
    53	    const un = deepUnwrap(r);
    54	    return (un == null) ? fallback : un;
    55	  } catch {
    56	    return fallback;
    57	  }
    58	}
    59	
    60	export async function setJSON(key, val, ttlSec) {
    61	  // Toujours stocker un JSON propre (pas de sur-emballage)
    62	  const body = { value: JSON.stringify(val) };
    63	  if (ttlSec) body.ttl = ttlSec;
    64	  await kvFetch(`/set/${encodeURIComponent(key)}`, 'POST', body);
    65	  return true;
    66	}
    67	
    68	export async function del(key) {
    69	  await kvFetch(`/del/${encodeURIComponent(key)}`, 'POST');
    70	  return true;
    71	}
    72	
    73	const NS = 'creatorbottg';
    74	function k(...parts) { return [NS, ...parts].join(':'); }
    75	
    76	export function keysForUser(uid) {
    77	  return {
    78	    budgetGlobal: k('budget','global'),
    79	    projectsList: k('projects','list'),
    80	    project: (pid) => k('project', pid),
    81	    secretsGlobal: k('secrets','global'),
    82	    secretsProject: (pid) => k('secrets','project', pid),
    83	    tmp: k('tmp', uid),      // mémoire par utilisateur
    84	    usageGlobal: k('usage','global'),
    85	    usageProject: (pid) => k('usage','project', pid)
    86	  };
    87	}
    88	
    89	export function now(){ return Math.floor(Date.now()/1000); }
    90	
    91	export function pricePer1k(){
    92	  const envP = process.env.PRICE_PER_1K;
    93	  if (envP) return Number(envP);
    94	  return 0.005;
    95	}
    96	
    97	export function estimateTokens(str){
    98	  if (!str) return 0;
    99	  const chars = [...String(str)].length;
   100	  return Math.max(1, Math.round(chars/4));
   101	}
   102	
   103	export async function addUsage({ projectId, tokens }) {
   104	  const userUsageKey = `${NS}:usage:global`;
   105	  const projUsageKey = `${NS}:usage:project:${projectId || 'none'}`;
   106	  const p = pricePer1k();
   107	  const euros = (tokens/1000)*p;
   108	
   109	  const u = (await getJSON(userUsageKey)) || { tokens:0, euros:0, history:[] };
   110	  u.tokens += tokens;
   111	  u.euros = Number((u.euros + euros).toFixed(4));
   112	  u.history.push({ ts: now(), projectId: projectId || null, tokens, euros: Number(euros.toFixed(4)) });
   113	  await setJSON(userUsageKey, u);
   114	
   115	  const up = (await getJSON(projUsageKey)) || { tokens:0, euros:0, history:[] };
   116	  up.tokens += tokens;
   117	  up.euros = Number((up.euros + euros).toFixed(4));
   118	  up.history.push({ ts: now(), tokens, euros: Number(euros.toFixed(4)) });
   119	  await setJSON(projUsageKey, up);
   120	
   121	  return { euros: Number(euros.toFixed(4)) };
   122	}

----- FILE 7: ./api/creator.js -----
     1	const API = `https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}`;
     2	const ADMIN = String(process.env.ADMIN_TELEGRAM_ID || "").trim();
     3	import { getJSON, setJSON } from './_kv.js';
     4	import { summarizePrompt } from './_ai.js';
     5	
     6	function kb(rows){ return { reply_markup:{ inline_keyboard: rows } }; }
     7	function esc(s){ return String(s||'').replace(/[<&>]/g,c=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[c])); }
     8	
     9	async function reply(chatId, text, extra){
    10	  await fetch(`${API}/sendMessage`, {
    11	    method:'POST', headers:{'Content-Type':'application/json'},
    12	    body: JSON.stringify({ chat_id: chatId, text, parse_mode:'HTML', ...extra })
    13	  });
    14	}
    15	
    16	function keysFor(uid){
    17	  const base = 'creatorbottg';
    18	  return {
    19	    tmp: `${base}:tmp:${uid}`,
    20	    projects: `${base}:projects:${uid}`
    21	  };
    22	}
    23	
    24	async function getTMP(uid){
    25	  const k = keysFor(uid).tmp;
    26	  const j = await getJSON(k);
    27	  try{
    28	    if (!j) return null;
    29	    const v = typeof j.value === 'string' ? JSON.parse(j.value) : j.value;
    30	    return v || null;
    31	  }catch{ return null; }
    32	}
    33	
    34	async function setTMP(uid, obj){
    35	  const k = keysFor(uid).tmp;
    36	  await setJSON(k, obj, 1800);
    37	}
    38	
    39	function isAdmin(uid){ return ADMIN ? String(uid)===ADMIN : true; }
    40	
    41	async function showMenu(chatId){
    42	  await reply(chatId, 'CreatorBot-TG en ligne ✅\nChoisis une action :', kb([
    43	    [{ text:'🆕 Nouveau projet', callback_data:'act:new' }, { text:'📁 Projets', callback_data:'act:list' }],
    44	    [{ text:'💰 Budget', callback_data:'act:budget' }, { text:'🔑 Secrets', callback_data:'act:secrets' }],
    45	    [{ text:'📦 ZIP', callback_data:'act:zip' }, { text:'♻️ Reset', callback_data:'act:reset' }]
    46	  ]));
    47	}
    48	
    49	async function askTitle(chatId, uid){
    50	  await setTMP(uid, { step:'title' });
    51	  await reply(chatId, 'Titre du projet ?', kb([[{ text:'⬅ Retour menu', callback_data:'act:menu' }]]));
    52	}
    53	
    54	async function askBudget(chatId, uid){
    55	  const tmp = await getTMP(uid) || {};
    56	  const title = tmp.title || '';
    57	  await setTMP(uid, { step:'budget', title });
    58	  await reply(chatId, `Budget pour <b>${esc(title)}</b>`, kb([
    59	    [{ text:'Cap 10€', callback_data:'b:cap:1000' }, { text:'Cap 20€', callback_data:'b:cap:2000' }],
    60	    [{ text:'Alerte 1€', callback_data:'b:alert:100' }, { text:'Alerte 2€', callback_data:'b:alert:200' }],
    61	    [{ text:'OK', callback_data:'b:ok' }, { text:'⬅ Annuler', callback_data:'act:menu' }]
    62	  ]));
    63	}
    64	
    65	async function askPrompt(chatId, uid){
    66	  const tmp = await getTMP(uid) || {};
    67	  await setTMP(uid, { step:'prompt', title: tmp.title, capCents: tmp.capCents||0, alertStepCents: tmp.alertStepCents||0 });
    68	  await reply(chatId, 'Envoie le prompt principal (objectif, contraintes, livrables, etc.)', kb([[{ text:'⬅ Annuler', callback_data:'act:menu' }]]));
    69	}
    70	
    71	async function showConfirm(chatId, uid){
    72	  const tmp = await getTMP(uid) || {};
    73	  const summary = tmp.summary || '';
    74	  await setTMP(uid, { ...tmp, step:'confirm' });
    75	  await reply(chatId, `Résumé compris :\n\n${esc(summary)}\n\nValider ?`, kb([
    76	    [{ text:'✅ Valider', callback_data:'confirm:ok' }, { text:'✏️ Modifier', callback_data:'confirm:edit' }],
    77	    [{ text:'⬅ Annuler', callback_data:'act:menu' }]
    78	  ]));
    79	}
    80	
    81	
    82	async function handleText(chatId, uid, text){
    83	  // PATCH anti-bug: fallback par défaut sur 'title', puis enchaîne vers Budget
    84	  try {
    85	    const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
    86	    const keys = keysForUser(String(userId));
    87	    let tmp = (await getJSON(keys.tmp)) || {};
    88	    if (!tmp.step) { tmp.step = 'title'; await setJSON(keys.tmp, tmp, 1800); }
    89	
    90	    if (tmp.step === 'title') {
    91	      const title = String(text || '').trim();
    92	      if (!title) { await reply(chatId, 'Envoie un titre valide.'); return; }
    93	      tmp.title = title;
    94	      tmp.step = 'budget';
    95	      await setJSON(keys.tmp, tmp, 1800);
    96	
    97	      const kb = kbInline([
    98	        [{ text:'Cap 10€',  callback_data:'bud:cap:1000' }, { text:'Cap 20€',  callback_data:'bud:cap:2000' }],
    99	        [{ text:'Alerte 1€',callback_data:'bud:alert:100' }, { text:'Alerte 2€',callback_data:'bud:alert:200' }],
   100	        [{ text:'OK',      callback_data:'bud:ok'        }, { text:'⬅️ Annuler', callback_data:'act:menu' }]
   101	      ]);
   102	      await reply(chatId, `Budget pour <b>${esc(title)}</b>`, kb);
   103	      return;
   104	    }
   105	  } catch(e) {
   106	    try { await reply(chatId, 'Erreur: ' + String(e)); } catch {}
   107	  }
   108	{
   109	    const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
   110	    const keys = keysForUser(String(userId));
   111	    const tmp = (await getJSON(keys.tmp)) || {};
   112	    if (tmp.step === 'secrets') {
   113	      const lines = String(text||'').split(/\r?\n/).map(v=>v.trim()).filter(Boolean);
   114	      const envs = {};
   115	      for (const l of lines){
   116	        const m = l.match(/^([A-Z0-9_]+)s*=s*(.+)$/);
   117	        if (m) envs[m[1]] = m[2];
   118	      }
   119	      tmp.secrets = Object.assign({}, tmp.secrets||{}, envs);
   120	      await setJSON(keys.tmp, tmp, 1800);
   121	
   122	      const need = ['TELEGRAM_BOT_TOKEN','OPENAI_API_KEY','KV_REST_API_URL','KV_REST_API_TOKEN'];
   123	      const missing = need.filter(k=>!tmp.secrets?.[k]);
   124	
   125	      if (missing.length){
   126	        await reply(chatId, "Reçu. Il manque encore : " + missing.join(', ') + ". Ajoute-les (même format KEY=VALUE).");
   127	      }else{
   128	        const kb = kbInline([
   129	          [{ text:'🚀 Générer le projet', callback_data:'gen:go' }],
   130	          [{ text:'⬅️ Annuler', callback_data:'act:menu' }]
   131	        ]);
   132	        await reply(chatId, "Parfait, j’ai tout. Prêt à **générer le projet** (code + README).", kb);
   133	      }
   134	      return;
   135	    }
   136	  }
   137	const tmp = await getTMP(uid);
   138	  if (!tmp) return showMenu(chatId);
   139	
   140	  if (tmp.step === 'title'){
   141	    const title = text.trim();
   142	    await setTMP(uid, { step:'budget', title });
   143	    await reply(chatId, `Titre enregistré : <b>${esc(title)}</b>`);
   144	    await askBudget(chatId, uid);
   145	    return;
   146	  }
   147	
   148	  if (tmp.step === 'prompt'){
   149	    const userPrompt = text.trim();
   150	    await reply(chatId, 'Je réfléchis au résumé…');
   151	    let summary = '';
   152	    try{ summary = await summarizePrompt(userPrompt); }
   153	    catch(e){ summary = `Impossible de résumer: ${String(e)}`; }
   154	    await setTMP(uid, { step:'confirm', title: tmp.title, capCents: tmp.capCents||0, alertStepCents: tmp.alertStepCents||0, prompt:userPrompt, summary });
   155	    await showConfirm(chatId, uid);
   156	    return;
   157	  }
   158	
   159	  await showMenu(chatId);
   160	}
   161	
   162	async function handleCallback(chatId, uid, data){
   163	  
   164	  
   165	  
   166	  
   167	  if (data && data.startsWith('gen:go')) {
   168	    const { keysForUser, getJSON } = await import('./_kv.js');
   169	    const keys = keysForUser(String(userId));
   170	    const tmp = (await getJSON(keys.tmp)) || {};
   171	    await reply(chatId, "OK, je génère les fichiers du projet (code + README)…");
   172	    // Ici, tu brancheras la vraie génération ZIP/Git. Pour l’instant on confirme.
   173	    await reply(chatId, "✅ Projet généré (brouillon). Étape suivante: packaging ZIP et déploiement automatique.");
   174	    return;
   175	  }
   176	if (data && data.startsWith('sec:help')) {
   177	    await reply(chatId, "• TELEGRAM_BOT_TOKEN : @BotFather → /newbot → Copier le token.\n• OPENAI_API_KEY : https://platform.openai.com/\n• KV (Upstash) : créer une base REST et récupérer URL & TOKEN.");
   178	    return;
   179	  }
   180	if (data && data.startsWith('plan:ok')) {
   181	    const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
   182	    const keys = keysForUser(String(userId));
   183	    const tmp = (await getJSON(keys.tmp)) || {};
   184	    tmp.step = 'secrets';
   185	    await setJSON(keys.tmp, tmp, 1800);
   186	    const kb = kbInline([
   187	      [{ text:'❓ Où trouver les tokens ?', callback_data:'sec:help' }],
   188	      [{ text:'⬅️ Annuler', callback_data:'act:menu' }]
   189	    ]);
   190	    await reply(chatId,
   191	      "Parfait. Maintenant, envoie-moi les **secrets** nécessaires dans ce format :\n\n" +
   192	      "TELEGRAM_BOT_TOKEN=xxxx\nOPENAI_API_KEY=xxxx\nKV_REST_API_URL=xxxx\nKV_REST_API_TOKEN=xxxx\n\n" +
   193	      "Tu peux ne fournir que ceux dont tu disposes, je te dirai s’il en manque.",
   194	      kb
   195	    );
   196	    return;
   197	  }
   198	// Suite après validation du résumé
   199	  if (data && data.startsWith('sum:ok')) {
   200	    await onSummaryOk(chatId, userId);
   201	    return;
   202	  }
   203	  if (data && data.startsWith('sum:edit')) {
   204	    const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
   205	    const keys = keysForUser(String(userId));
   206	    const tmp = (await getJSON(keys.tmp)) || {};
   207	    tmp.step = 'prompt';
   208	    await setJSON(keys.tmp, tmp, 1800);
   209	    await reply(chatId, 'Ok, renvoie le prompt principal (objectif, contraintes, livrables, etc.).');
   210	    return;
   211	  }
   212	const tmp = await getTMP(uid) || {};
   213	
   214	  if (data === 'act:menu'){ await setTMP(uid, null); await showMenu(chatId); return; }
   215	  if (data === 'act:new'){ await askTitle(chatId, uid); return; }
   216	
   217	  if (data.startsWith('b:')){
   218	    const [_, kind, val] = data.split(':');
   219	    if (tmp.step!=='budget'){ await askBudget(chatId, uid); return; }
   220	    if (kind==='cap'){ await setTMP(uid, { ...tmp, capCents:Number(val) }); await reply(chatId, `Cap défini: ${(Number(val)/100).toFixed(2)} €`); }
   221	    if (kind==='alert'){ await setTMP(uid, { ...tmp, alertStepCents:Number(val) }); await reply(chatId, `Alerte: ${(Number(val)/100).toFixed(2)} €`); }
   222	    if (kind==='ok'){ await askPrompt(chatId, uid); }
   223	    return;
   224	  }
   225	
   226	  if (data === 'confirm:edit'){
   227	    await askPrompt(chatId, uid);
   228	    return;
   229	  }
   230	
   231	  if (data === 'confirm:ok'){
   232	    await setTMP(uid, { ...tmp, step:'done' });
   233	    await reply(chatId, '✅ Validé. Étapes suivantes : faisabilité, plan stratégique, plan d’action, besoins et livrables. (On les génère juste après.)');
   234	    return;
   235	  }
   236	
   237	  if (data === 'act:list'){ await reply(chatId,'Projets (à venir).'); return; }
   238	  if (data === 'act:budget'){ await reply(chatId,'Budget global (à venir).'); return; }
   239	  if (data === 'act:secrets'){ await reply(chatId,'Secrets (à venir).'); return; }
   240	  if (data === 'act:zip'){ await reply(chatId,'ZIP (à venir).'); return; }
   241	  if (data === 'act:reset'){ await setTMP(uid, null); await reply(chatId,'État réinitialisé.'); await showMenu(chatId); return; }
   242	
   243	  await showMenu(chatId);
   244	}
   245	
   246	export default async function handler(req,res){
   247	  if (req.method === 'GET') return res.status(200).send('OK');
   248	  if (req.method !== 'POST') return res.status(405).json({ ok:false });
   249	
   250	  try{
   251	    const u = req.body || {};
   252	    const msg = u.message;
   253	    const cb  = u.callback_query;
   254	
   255	    if (msg && msg.text){
   256	      const chatId = msg.chat?.id;
   257	      const fromId = msg.from?.id;
   258	      if (!isAdmin(fromId)){ await reply(chatId,'❌ Accès refusé – bot privé.'); return res.json({ok:true}); }
   259	      if (msg.text === '/start'){ await showMenu(chatId); return res.json({ok:true}); }
   260	      await handleText(chatId, fromId, msg.text);
   261	      return res.json({ ok:true });
   262	    }
   263	
   264	    if (cb){
   265	      const chatId = cb.message?.chat?.id;
   266	      const fromId = cb.from?.id;
   267	      if (!isAdmin(fromId)){ await reply(chatId,'❌ Accès refusé – bot privé.'); return res.json({ok:true}); }
   268	      await handleCallback(chatId, fromId, cb.data||'');
   269	      await fetch(`${API}/answerCallbackQuery`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ callback_query_id: cb.id }) });
   270	      return res.json({ ok:true });
   271	    }
   272	
   273	    return res.json({ ok:true });
   274	  }catch(e){
   275	    return res.status(200).json({ ok:false, error: String(e) });
   276	  }
   277	}
   278	
   279	
   280	async function askOpenAI(messages){
   281	  const api = process.env.OPENAI_API_KEY;
   282	  const model = process.env.OPENAI_MODEL || 'gpt-4o-mini';
   283	  const r = await fetch('https://api.openai.com/v1/chat/completions',{
   284	    method:'POST',
   285	    headers:{ 'Content-Type':'application/json', 'Authorization':'Bearer '+api },
   286	    body: JSON.stringify({ model, messages, temperature:0.3 })
   287	  });
   288	  const j = await r.json();
   289	  const txt = j?.choices?.[0]?.message?.content?.trim() || '';
   290	  return txt;
   291	}
   292	
   293	async function onSummaryOk(chatId, userId){
   294	  const { keysForUser, getJSON, setJSON } = await import('./_kv.js');
   295	  const keys = keysForUser(String(userId));
   296	  const tmp  = (await getJSON(keys.tmp)) || {};
   297	  const title = tmp.title || 'Projet';
   298	  const prompt = tmp.prompt || '';
   299	
   300	  const sys = `Tu es un architecte logiciel Telegram ultra rigoureux.
   301	Réponds en français, format clair avec titres **gras** et listes.
   302	Tu dois fournir: Faisabilité, Plan stratégique (phases), Plan d'action (tâches), Besoins (inputs & secrets), Livrables (code, README, déploiement).
   303	Sois concret, pas verbeux.`;
   304	
   305	  const usr = `Titre: ${title}
   306	Brief utilisateur:
   307	${prompt}`;
   308	
   309	  // Message d'attente
   310	  await reply(chatId, 'Je prépare la faisabilité et le plan…');
   311	
   312	  const plan = await askOpenAI([
   313	    { role:'system', content: sys },
   314	    { role:'user', content: usr }
   315	  ]);
   316	
   317	  // Mémorise et propose la suite
   318	  tmp.step = 'plan';
   319	  tmp.plan = plan;
   320	  await setJSON(keys.tmp, tmp, 1800);
   321	
   322	  const kb = kbInline([
   323	    [{ text:'✅ Continuer', callback_data:'plan:ok' }],
   324	    [{ text:'✏️ Modifier le brief', callback_data:'sum:edit' }],
   325	    [{ text:'⬅️ Annuler', callback_data:'act:menu' }]
   326	  ]);
   327	
   328	  await reply(chatId, `**Faisabilité & Plan pour ${esc(title)}**\n\n${plan}`, kb);
   329	}

----- FILE 8: ./api/diag.js -----
     1	import { getJSON, setJSON, keysForUser } from './_kv.js';
     2	export default async function handler(req, res) {
     3	  try {
     4	    if (req.query?.dump === '1') {
     5	      const uid = String(req.query.uid || '').trim();
     6	      const keys = keysForUser(uid || 'debug');
     7	      const state = {
     8	        uid,
     9	        tmp: uid ? await getJSON(keys.tmp) : null,
    10	        budgetGlobal: await getJSON(keys.budgetGlobal),
    11	        projectsList: await getJSON(keys.projectsList),
    12	      };
    13	      return res.status(200).json({ ok: true, state });
    14	    }
    15	    if (req.query?.kvtest === '1') {
    16	      const key = String(req.query.key || 'creatorbottg:test');
    17	      const val = String(req.query.val || 'hello');
    18	      await setJSON(key, { v: val, ts: Date.now() });
    19	      const back = await getJSON(key);
    20	      return res.status(200).json({ ok: true, set: { key, val }, get: back });
    21	    }
    22	    return res.status(200).json({ ok:true, ts: Date.now() });
    23	  } catch (e) {
    24	    return res.status(200).json({ ok:false, error: String(e) });
    25	  }
    26	}

----- FILE 9: ./package.json -----
     1	{
     2	  "name": "creator-bot-tg",
     3	  "version": "1.0.0",
     4	  "private": true,
     5	  "type": "module",
     6	  "dependencies": {
     7	    "adm-zip": "0.5.10"
     8	  },
     9	  "engines": {
    10	    "node": "20.x"
    11	  }
    12	}

